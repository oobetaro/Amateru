/*
 * EventEditPanel.java
 *
 * Created on 2006/10/03, 21:06
 */

package to.tetramorph.starbase;

import java.awt.Color;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.util.ArrayList;
import java.util.List;
import java.util.TimeZone;
import javax.swing.Icon;
import javax.swing.JLabel;
import javax.swing.JTable;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumnModel;
import to.tetramorph.starbase.lib.Transit;

/**
 * Eventを編集するためのパネルだか、このクラスは直接使わず継承してコンポジットと
 * ヒストリーを編集するパネルにして使われる。
 * このパネルにとりつけられた「追加・変更・削除」それぞれのボタンに、サブクラスで
 * イベントを登録する。
 * getEventList(..)で編集されたデータのリストを取得できる。
 *
 * setEventList(..)で渡されたリストは、DBにテンポラリ表を使ってそこに一時登録され
 * その中で編集作業を行っている。ソートなどで管理が行いやすいため。
 */
class EventEditPanel extends javax.swing.JPanel {
    // ソート状態「降り順」を意味する定数
    static final int DESCENDING = 2;
    // ソート状態「ソートなし」を意味する定数
    static final int NOT_SORTED = 0;
    // ソート状態「登り順」を意味する定数
    static final int ASCENDING = 1;
    protected List<Transit> eventList = new ArrayList<Transit>();
    protected String tableName = "HISTORY";
    private static String [] columnNames = { "名前","日時","場所","メモ" };
    private Directive [] directive;
    //private Database db;
    private DB db;
    private Connection con;
    private int tableCode;
    /**
     * オブジェクトを作成。
     */
    protected EventEditPanel() {
        initComponents();
        init();
    }
    /**
     * テーブル名を指定してオブジェクトを作成。
     * テーブル名に"HISTORY"や"COMPOSIT"を指定することで、その名前を使ったメモリ
     * テーブルがDB上に作成され、Eventデータのリストをその表で管理する。
     */
    protected EventEditPanel(String tableName) {
        this.tableName = tableName;
        tableCode = (tableName.equals("HISTORY")) ? 
            DBFactory.HISTORY_TABLE_CODE : DBFactory.COMPOSIT_TABLE_CODE; 
        initComponents();
        init();
    }
    //DB上にメモリテーブルを作ったりJTableの初期設定
    private void init() {
        directive = new Directive[ columnNames.length ];
        for(int i=0; i<directive.length; i++)
            directive[i] = new Directive(i,NOT_SORTED);
        JTableHeader tableHeader = table.getTableHeader();
        TableHeaderRenderer render = new TableHeaderRenderer(
            tableHeader.getDefaultRenderer());
        tableHeader.setDefaultRenderer(render);
        tableHeader.addMouseListener(new MouseHandler());
        table.setModel(new EventTableModel());
        //db = Database.getInstance();
        db = DBFactory.getInstance();
        db.createEventTable( tableCode );
//        con = db.getConnection();
//        StringBuffer sb = new StringBuffer();
//        sb.append("CREATE MEMORY TABLE " + tableName + "_TEMP(");
//        sb.append(" ID INTEGER ");
//        sb.append(" GENERATED BY DEFAULT AS IDENTITY(START WITH 1,INCREMENT BY 1)");
//        sb.append(" NOT NULL PRIMARY KEY,");
//        sb.append(" NAME      VARCHAR(20)  DEFAULT '' NOT NULL,");
//        sb.append(" MEMO      VARCHAR(20)  DEFAULT '' NOT NULL,");
//        sb.append(" ERA       VARCHAR(2)   DEFAULT 'AD' NOT NULL,");        /* [AD],BCのフラグ */
//        sb.append(" DATE      DATE         NOT NULL,");                     /* この日付はNULLを許さない */
//        sb.append(" TIME      TIME,");
//        sb.append(" PLACENAME VARCHAR(20)  DEFAULT '' NOT NULL,");
//        sb.append(" LATITUDE  DOUBLE,");
//        sb.append(" LONGITUDE DOUBLE,");
//        sb.append(" TIMEZONE  VARCHAR(20)  DEFAULT '' NOT NULL,");
//        sb.append(" JDAY      DOUBLE");
//        sb.append(")");
//        Statement stmt = null;
//        try {
//            stmt = con.createStatement();
//            stmt.executeUpdate("DROP TABLE " + tableName + "_TEMP IF EXISTS");
//            stmt.executeUpdate(sb.toString());
//        } catch(SQLException e) {
//            e.printStackTrace();
//        } finally {
//            //db.close(stmt);
//            try { stmt.close(); } catch(Exception e) { }
//        }
    }
    private class EventTableModel extends AbstractTableModel {
        public int getColumnCount() { return columnNames.length; }
        public int getRowCount() { return eventList.size();}
        //何のオブジェクトがセルに入っているかを返す
        public Object getValueAt(int row, int col) {
            Transit event = eventList.get(row);
            String name = columnNames[col];
            if(name.equals("名前")) return event.getName();
            if(name.equals("日時")) return event.getFormattedDate();
            if(name.equals("場所")) return event.getPlaceName();
            if(name.equals("メモ")) return event.getMemo();
            return "あれー？";
        }
        public String getColumnName(int column) { return columnNames[column]; }
        public Class getColumnClass(int c) {
            return getValueAt(0, c).getClass(); }
        public boolean isCellEditable(int row, int col) { return false; }
        public void setValueAt(Object aValue, int row, int column) {
        }
    }
    
    //テーブルヘッダーがマウスクリックされたのを拾う
    private class MouseHandler extends MouseAdapter {
        public void mouseClicked(MouseEvent e) {
            JTableHeader h = (JTableHeader) e.getSource();
            TableColumnModel columnModel = h.getColumnModel();
            int viewColumn = columnModel.getColumnIndexAtX(e.getX());
            int column = columnModel.getColumn(viewColumn).getModelIndex();
            if (column != -1) {
                directive[column].direction++;
                if(directive[column].direction >= 3) directive[column].direction = 0;
                for(int i=0; i<columnNames.length; i++) {
                    if(i == column) continue;
                    directive[i].direction = 0;
                }
                updateEventTableModel();
            }
        }
    }
    
    //テーブルヘッダの▽△でソート順位を表すアイコン
    private static class Arrow implements Icon {
        private boolean descending;
        private int size;
        private int priority;
        public Arrow(boolean descending, int size, int priority) {
            this.descending = descending;
            this.size = size;
            this.priority = priority;
        }
        
        public void paintIcon(Component c, Graphics g, int x, int y) {
            Color color = c == null ? Color.GRAY : c.getBackground();
            // In a compound sort, make each succesive triangle 20%
            // smaller than the previous one.
            int dx = (int)(size/2*Math.pow(0.8, priority));
            int dy = descending ? dx : -dx;
            // Align icon (roughly) with font baseline.
            y = y + 5*size/6 + (descending ? -dy : 0);
            int shift = descending ? 1 : -1;
            g.translate(x, y);
            
            // Right diagonal.
            g.setColor(color.darker());
            g.drawLine(dx / 2, dy, 0, 0);
            g.drawLine(dx / 2, dy + shift, 0, shift);
            
            // Left diagonal.
            g.setColor(color.brighter());
            g.drawLine(dx / 2, dy, dx, 0);
            g.drawLine(dx / 2, dy + shift, dx, shift);
            
            // Horizontal line.
            if (descending) {
                g.setColor(color.darker().darker());
            } else {
                g.setColor(color.brighter().brighter());
            }
            g.drawLine(dx, 0, 0, 0);
            
            g.setColor(color);
            g.translate(-x, -y);
        }
        
        public int getIconWidth() {
            return size;
        }
        
        public int getIconHeight() {
            return size;
        }
    }
    
    //テーブルヘッダのレンダラ
    private class TableHeaderRenderer implements TableCellRenderer {
        private TableCellRenderer tableCellRenderer;
        
        public TableHeaderRenderer(TableCellRenderer tableCellRenderer) {
            this.tableCellRenderer = tableCellRenderer;
        }
        
        public Component getTableCellRendererComponent(JTable table,
            Object value,
            boolean isSelected,
            boolean hasFocus,
            int row,
            int column) {
            Component c = tableCellRenderer.getTableCellRendererComponent(
                table,value, isSelected, hasFocus, row, column);
            if (c instanceof JLabel) {
                JLabel l = (JLabel) c;
                l.setHorizontalTextPosition(JLabel.LEFT);
                int modelColumn = table.convertColumnIndexToModel(column);
                Arrow arrowIcon = null;
                if(directive[modelColumn].direction != NOT_SORTED)
                    arrowIcon = new Arrow(
                        directive[modelColumn].direction == DESCENDING, 18,1);
                l.setIcon(arrowIcon);
            }
            return c;
        }
    }
    
    //ソート方向を保持するための単純なクラス
    private static class Directive {
        private int column;
        private int direction;
        
        public Directive(int column, int direction) {
            this.column = column;
            this.direction = direction;
        }
    }
    
    //tableName_TEMP表に登録されているﾃﾞｰﾀをﾃｰﾌﾞﾙﾓﾃﾞﾙに読み込みﾃｰﾌﾞﾙに再描画を要求。
/**
    private void updateEventTableModel() {
        String [] fieldNames = { "NAME","JDAY","PLACENAME","MEMO" };
        int column = -1;
        eventList.clear();
        for(int i=0; i<directive.length; i++) {
            if(directive[i].direction != NOT_SORTED) {
                column = i;
                break;
            }
        }
        String sql = "SELECT * FROM " + tableName + "_TEMP";
        if(column >= 0) {
            int direction = directive[column].direction;
            String dir = direction == DESCENDING ? "DESC" : "ASC";
            sql += " ORDER BY " + fieldNames[column] + " " + dir;
        }
        Statement stmt = null;
        ResultSet rs = null;
        try {
            stmt = con.createStatement();
            rs = stmt.executeQuery(sql);
            while(rs.next()) {
                Transit event = new Transit();
                event.setPrimaryKey(rs.getInt("ID"));
                event.setName(rs.getString("NAME"));
                event.setMemo(rs.getString("MEMO"));
                Date date = rs.getDate("DATE");
                String era = rs.getString("ERA");
                event.setDate(date,era);
                event.setTime(rs.getTime("TIME"));
                event.setPlaceName(rs.getString("PLACENAME"));
                // getDoubleは戻り値がDoubleではなくdoubleなので
                // 事前確認(NULLが代入できない)
                if(rs.getString("LATITUDE") != null)
                    event.setLatitude(rs.getDouble("LATITUDE"));
                if(rs.getString("LONGITUDE") != null)
                    event.setLongitude(rs.getDouble("LONGITUDE"));
                event.setTimeZone(TimeZone.getTimeZone(rs.getString("TIMEZONE")));
                eventList.add(event);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try { stmt.close(); } catch(Exception e) { }
            try { rs.close(); } catch(Exception e) { }
        }
        table.revalidate();
    }
*/
    private void updateEventTableModel() {
        String [] fieldNames = { "NAME","JDAY","PLACENAME","MEMO" };
        int column = -1;
        eventList.clear();
        //どの列でソート方向が指定されてるか求める。どこにも指定されてなければ、
        // column = -1　            column = fieldCode
        for(int i=0; i<directive.length; i++) {
            if(directive[i].direction != NOT_SORTED) {
                column = i;
                break;
            }
        }
        int direction = ( column >= 0 ) ? directive[column].direction : -1;
        db.getEventList( tableCode, direction, column, eventList);
        table.revalidate();
    }
    /**
     * 登録されたヒストリーのリストを返す。
     * なおデータがなくてもsize()==0のリストを返す。
     * @return Eventオブジェクトを格納したリスト。
     */
    public List<Transit> getEventList() {
        return db.getEventList( tableCode );
    }
/**
    public List<Transit> getEventList() {
        //DBのヒストリー(テンポラリ表)から編集の終わったリストを読み出し配列にして返す。
        List<Transit> historyList = new ArrayList<Transit>();
        ResultSet rs = null;
        PreparedStatement ps = null;
        try {
            ps = con.prepareStatement(
                "SELECT * FROM " + tableName + "_TEMP ORDER BY JDAY ASC");
            rs = ps.executeQuery();
            while(rs.next()) {
                Transit event = new Transit();
                event.setParams(rs);
                event.setPrimaryKey(rs.getInt("ID"));
                historyList.add(event);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try { ps.close(); } catch(Exception e) { }
            try { rs.close(); } catch(Exception e) { }
        }
        return historyList;
    }
 */
    /**
     * Eventのリストを登録する。更新作業の時に必要になる。
     */
    protected void setEventList(List<Transit> eventList) {
        for(int i=0; i<eventList.size(); i++) {
            db.addEvent( tableCode, eventList.get(i) ); // *_TEMP表に挿入
        }
        updateEventTableModel();
    }
 /**
    protected void setEventList(List<Transit> eventList) {
        for(int i=0; i<eventList.size(); i++) {
            insert(eventList.get(i)); // *_TEMP表に挿入
        }
        updateEventTableModel();
    }
  */
    /**
     * Eventデータを表に挿入する
     */
    protected void insert(Transit event) {
        db.addEvent( tableCode, event );
    }
  /**
    protected void insert(Transit event) {
        PreparedStatement ps = null;
        try {
            String sql = "INSERT INTO " + tableName
                + "_TEMP(NAME,MEMO,ERA,DATE,TIME,PLACENAME,"
                + "LATITUDE,LONGITUDE,TIMEZONE,JDAY) "
                + "VALUES(?,?,?,?,?,?,?,?,?,?)";
            ps = con.prepareStatement(sql);
            ps.setString(1,event.getName());
            ps.setString(2,event.getMemo());
            ps.setString(3,event.getERA());
            ps.setDate(4,event.getDate());
            if(event.getTime() == null) ps.setNull(5,Types.NULL);
            else ps.setTime(5,event.getTime());
            ps.setString(6,event.getPlaceName());
            if(event.getLatitude() == null) ps.setNull(7,Types.NULL);
            else ps.setDouble(7,event.getLatitude());
            if(event.getLongitude() == null) ps.setNull(8,Types.NULL);
            else ps.setDouble(8,event.getLongitude());
            ps.setString(9,event.getTimeZone().getID());
            ps.setDouble(10,event.getJDay());
            ps.executeUpdate();
        } catch ( SQLException e ) {
            e.printStackTrace();
        } finally {
            db.close(ps);
        }
    }
   */
    /**
     * 削除ボタンが押されたら選択されているEventを削除する。
     */
    private void deleteButtonActionPerformed() {
        int row = table.getSelectedRow();
        if( row < 0 ) return;
        Transit event = eventList.get(row);
        db.removeEvent( tableCode, event );
        updateEventTableModel();
    }
  /**
    private void deleteButtonActionPerformed() {
        int row = table.getSelectedRow();
        if( row < 0 ) return;
        Transit event = eventList.get(row);
        PreparedStatement ps = null;
        try {
            ps = con.prepareStatement("DELETE FROM " + tableName + "_TEMP WHERE ID=?");
            ps.setInt(1,event.getPrimaryKey());
            ps.executeUpdate();
        } catch( SQLException e) {
            e.printStackTrace();
        } finally {
            db.close(ps);
        }
        updateEventTableModel();
    }
 */   
    /**
     * Eventデータを更新
     */
    protected void updateButtonActionPerformed( Transit event ) {
        db.updateEvent( tableCode, event );
    }
 /** 
    protected void updateButtonActionPerformed(Transit event) {
        String sql = "UPDATE "+tableName+"_TEMP SET NAME=?,MEMO=?,DATE=?,TIME=?,"
            + "PLACENAME=?,LATITUDE=?,LONGITUDE=?,TIMEZONE=?,JDAY=? "
            + "WHERE ID=?";
        PreparedStatement ps = null;
        try {
            ps = con.prepareStatement(sql);
            ps.setString(1,event.getName());
            ps.setString(2,event.getMemo());
            ps.setDate(3,event.getDate());
            if(event.getTime() == null) ps.setNull(4,Types.NULL);
            else ps.setTime(4,event.getTime());
            ps.setString(5,event.getPlaceName());
            if(event.getLatitude() == null) ps.setNull(6,Types.NULL);
            else ps.setDouble(6,event.getLatitude());
            if(event.getLongitude() == null) ps.setNull(7,Types.NULL);
            else ps.setDouble(7,event.getLongitude());
            ps.setString(8,event.getTimeZone().getID());
            ps.setDouble(9,event.getJDay());
            ps.setInt(10,event.getPrimaryKey());
            ps.executeUpdate();
        } catch(SQLException e) {
            e.printStackTrace();
        } finally {
            db.close(ps);
        }
        updateEventTableModel();
    }
  */
    /**
     * Eventを登録する。
     */
    protected void registButtonActionPerformed(Transit event) {
        insert(event);
        updateEventTableModel();
    }
    
    public void addKeyListener(KeyListener l) {
        deleteButton.addKeyListener(l);
        registButton.addKeyListener(l);
        table.addKeyListener(l);
        updateButton.addKeyListener(l);
    }
  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  // <editor-fold defaultstate="collapsed" desc=" Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {
    javax.swing.JPanel buttonPanel;
    javax.swing.JScrollPane scrollPane;

    buttonPanel = new javax.swing.JPanel();
    registButton = new javax.swing.JButton();
    updateButton = new javax.swing.JButton();
    deleteButton = new javax.swing.JButton();
    scrollPane = new javax.swing.JScrollPane();
    table = new javax.swing.JTable();

    setLayout(new java.awt.BorderLayout());

    setMinimumSize(new java.awt.Dimension(420, 150));
    setName("\u30d2\u30b9\u30c8\u30ea\u30fc");
    setPreferredSize(new java.awt.Dimension(420, 150));
    buttonPanel.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.RIGHT));

    registButton.setMnemonic('A');
    registButton.setText("\u8ffd\u52a0(A)");
    buttonPanel.add(registButton);

    updateButton.setMnemonic('E');
    updateButton.setText("\u7de8\u96c6(E)");
    buttonPanel.add(updateButton);

    deleteButton.setMnemonic('D');
    deleteButton.setText("\u524a\u9664(D)");
    deleteButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        deleteButtonActionPerformed(evt);
      }
    });

    buttonPanel.add(deleteButton);

    add(buttonPanel, java.awt.BorderLayout.SOUTH);

    table.setModel(new javax.swing.table.DefaultTableModel(
      new Object [][] {
        {null, null, null, null},
        {null, null, null, null},
        {null, null, null, null},
        {null, null, null, null}
      },
      new String [] {
        "Title 1", "Title 2", "Title 3", "Title 4"
      }
    ));
    scrollPane.setViewportView(table);

    add(scrollPane, java.awt.BorderLayout.CENTER);

  }// </editor-fold>//GEN-END:initComponents

  private void deleteButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_deleteButtonActionPerformed
      deleteButtonActionPerformed();
  }//GEN-LAST:event_deleteButtonActionPerformed
  //ヒストリーデータを削除  //ヒストリーデータを登録  //ヒストリーデータを変更  
  
  // Variables declaration - do not modify//GEN-BEGIN:variables
  protected javax.swing.JButton deleteButton;
  protected javax.swing.JButton registButton;
  protected javax.swing.JTable table;
  protected javax.swing.JButton updateButton;
  // End of variables declaration//GEN-END:variables
  
}
